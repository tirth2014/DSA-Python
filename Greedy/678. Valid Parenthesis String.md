## [678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/)

<div class="elfjS" data-track-load="description_content"><p>Given a string <code>s</code> containing only three types of characters: <code>'('</code>, <code>')'</code> and <code>'*'</code>, return <code>true</code> <em>if</em> <code>s</code> <em>is <strong>valid</strong></em>.</p>

<p>The following rules define a <strong>valid</strong> string:</p>

<ul>
	<li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li>
	<li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li>
	<li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li>
	<li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string <code>""</code>.</li>
</ul>

<p>&nbsp;</p>
<p><strong class="example">Example 1:</strong></p>
<pre><strong>Input:</strong> s = "()"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 2:</strong></p>
<pre><strong>Input:</strong> s = "(*)"
<strong>Output:</strong> true
</pre><p><strong class="example">Example 3:</strong></p>
<pre><strong>Input:</strong> s = "(*))"
<strong>Output:</strong> true
</pre>
<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>s[i]</code> is <code>'('</code>, <code>')'</code> or <code>'*'</code>.</li>
</ul>
</div>

</br>

#### Other sample testcases:
 - "(()*()"
 - "((((()(()()()*()(((((*)()*(**(())))))(())()())(((())())())))))))(((((())*)))()))(()((*()*(*)))(*)()"
 - "(((((*)))**"


<hr/>

## Failed Attempt 1:

```py
class Solution:
    def checkValidString(self, s: str) -> bool:
        i, j = 0, len(s)-1

        while i < j:
            if s[i] in ['(', '*'] and s[j] in [')', '*']:
                i += 1
                j -= 1
            else:
                return False

        if i == j and s[i] != '*':
            return False

        return True
        
```

## Failed Attempt 2:

```py
class Solution:
    def checkValidString(self, s: str) -> bool:
        # HashMap to store count of each character and
        # to store heap of indices for each character in string
        map = {c: [] for c in ['(', ')', '*']}
        for i, c in enumerate(s):
            # map[c][0] = map[c][0] + 1
            heapq.heappush(map[c], i)

        if len(map['(']) != len(map[')']) and abs(len(map[')']) - len(map['('])) > len(map['*']):
            return False

        # while both of left and right or one among them is alive...
        while map['('] or map[')']:
            # if left parentheses count < right parentheses count
            # means we have to utilize '*' for left parentheses
            if len(map['(']) < len(map[')']):
                # if left parentheses smallest idx < star smallest idx
                if map['('] and (not map['*'] or map['('][0] < map['*'][0]):
                    left_idx = heapq.heappop(map['('])
                else:
                    left_idx = heapq.heappop(map['*'])
                right_idx = heapq.heappop(map[')'])

                if left_idx > right_idx:
                    return False

            # if right parentheses count < left parentheses count
            # means we have to utilize '*' for right parentheses
            elif len(map[')']) < len(map['(']):
                # if right parentheses smallest idx < star smallest idx
                if map[')'] and (not map['*'] or map[')'][0] < map['*'][0]):
                    right_idx = heapq.heappop(map[')'])
                else:
                    right_idx = heapq.heappop(map['*'])
                left_idx = heapq.heappop(map['('])

                if left_idx > right_idx:
                    return False

            # if left parentheses count is same as right parentheses count (both balanced)
            # means we don't need to utilize '*' for any parentheses
            else:
                left_idx = heapq.heappop(map['('])
                right_idx = heapq.heappop(map[')'])

                if left_idx > right_idx:
                    return False

        return True if not map[')'] and not map['('] else False
```

</br>

## Brute-Force DFS approach - explore all possibilities

```py
class Solution:
    def checkValidString(self, s: str) -> bool:
        # DFS approach (explore all possibilities)
        def dfs(i, open_cnt):
            if i == len(s):
                return open_cnt == 0

            if s[i] == '(':
                return dfs(i+1, open_cnt+1)
            elif s[i] == ')':
                if open_cnt > 0:
                    return dfs(i+1, open_cnt-1)
                else:
                    return False
            else:  # asterisk
                return (dfs(i+1, open_cnt) or
                        dfs(i+1, open_cnt+1) or
                        dfs(i+1, open_cnt-1))

        return dfs(0, 0)
```

</br>

## AC Solution - Top-Down DP (Memoization):

```py
class Solution:
    def checkValidString(self, s: str) -> bool:
        # Dictionary to store the results of subproblems.
        # key = (i, open_count) -> is_valid?
        dp = {(len(s), 0): True}

        # Recursive function to check validity with dynamic programming (memoization).
        def dfs(i, open_cnt):
            # Base case: If we have reached the end of the string or the open count becomes negative,
            # we return True if open count is 0, indicating balanced parentheses, and False otherwise.
            if i == len(s) or open_cnt < 0:
                return open_cnt == 0

            # If the result for the current state (i, open_cnt) is already calculated, return it.
            if (i, open_cnt) in dp:
                return dp[(i, open_cnt)]

            if s[i] == '(':
                dp[(i, open_cnt)] = dfs(i+1, open_cnt+1)
            elif s[i] == ')':
                dp[(i, open_cnt)] = dfs(i+1, open_cnt-1)
            else:  # asterisk, try all possibilities: '(' or ')' or '' (empty).
                dp[(i, open_cnt)] = (
                        dfs(i+1, open_cnt) or  # Empty - Do nothing
                        dfs(i+1, open_cnt+1) or  # '('
                        dfs(i+1, open_cnt-1)  # ')'
                )
            return dp[(i, open_cnt)]

        # Start the recursive function from the beginning of the string with an open count of 0.
        return dfs(0, 0)
```
